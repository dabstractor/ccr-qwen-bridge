# Product Requirements Document: Qwen-Claude Bridge

**Version:** 1.0
**Date:** August 15, 2025
**Author:** Gemini AI
**Status:** Draft

### 1. **Introduction & Executive Summary**

Project "Qwen-Claude Bridge" is a lightweight, stateful proxy server designed to unlock the 2,000 free daily API requests provided by Qwen-Code for use with third-party development tools. The primary target tool is `claude-code-router`, which expects a standard OpenAI-compatible API endpoint.

The core problem is that Qwen-Code's free tier is accessible only via a proprietary OAuth 2.0 Device Authorization Flow managed by their official Command Line Interface (CLI). This project will implement a server that manages this specific authentication lifecycle, maintaining a valid session and proxying requests, effectively emulating the official CLI's authenticated state.

### 2. **Problem Statement**

Developers want to leverage the generous free tier of Qwen-Code for their coding assistant workflows. However, they are often locked into using specific tools like `claude-code-router` that provide features like model routing, fallbacks, and a unified interface. Qwen-Code's CLI-based authentication prevents direct integration, forcing users to choose between their preferred tools and the free API credits. This project aims to eliminate that choice by creating a seamless bridge between the two.

### 3. **Goals & Objectives**

*   **Primary Goal:** To enable any OpenAI-compatible client (specifically `claude-code-router`) to successfully make API calls to the Qwen-Code API using the free daily request allowance.
*   **Key Objectives:**
    *   Successfully manage the Qwen-Code OAuth 2.0 session by automatically refreshing the access token.
    *   Maintain session persistence across server restarts by reading from and writing to the official Qwen-Code credentials file.
    *   Achieve high reliability with robust error handling and clear logging for diagnostics.
    *   Ensure low latency by performing authentication checks and refreshes efficiently.

### 4. **Target Audience**

*   **Primary:** Developers who use `claude-code-router` and wish to add Qwen-Code as a free, high-quality language model provider.
*   **Secondary:** Developers using other custom scripts or tools that are built to interface with OpenAI-compatible API endpoints.

### 5. **Product Scope & Features (V1)**

#### 5.1. **Core Functionality: Proxy Server**
*   **F-1.1:** The server shall listen on a configurable IP address and port for incoming HTTP requests.
*   **F-1.2:** The server shall accept OpenAI-compatible Chat Completion requests (`/v1/chat/completions`).
*   **F-1.3:** It shall forward these requests to the appropriate Qwen-Code API endpoint, translating the request format if necessary.
*   **F-1.4:** It shall transform the response from Qwen-Code back into the OpenAI-compatible format and return it to the original client.

#### 5.2. **Authentication & Session Management**
*   **F-2.1: Initial State:** The server requires a pre-existing, valid `oauth_creds.json` file generated by the official `qwen-code` CLI. It will not handle the initial, user-interactive device authorization flow.
*   **F-2.2: Credential Loading:** On startup, the server must locate and read the credentials from `~/.qwen/oauth_creds.json`.
*   **F-2.3: State Management:** The server must parse and hold the `access_token`, `refresh_token`, and `expiry_date` (Unix timestamp in ms) in memory.
*   **F-2.4: Proactive Token Refresh:** Before proxying any incoming API request, the server must check if the current `access_token` is expired (`Date.now() > expiry_date`).
*   **F-2.5: Refresh Logic:** If the token is expired, the server must automatically perform a token refresh by making a POST request to the token endpoint. This request must be executed exactly as specified in the Technical Requirements (Section 6.4).
*   **F-2.6: Credential Persistence:** Upon a successful token refresh, the server must immediately and atomically write the new `access_token`, `refresh_token`, and calculated `expiry_date` back to the `~/.qwen/oauth_creds.json` file.
*   **F-2.7: Authorization Header:** For every proxied request to Qwen-Code, the server must include the valid `access_token` in the `Authorization` header as a Bearer token (`Authorization: Bearer <access_token>`).

#### 5.3. **Configuration**
*   **F-3.1:** The server's listening host and port must be configurable via a simple configuration file (e.g., `.env`, `config.yaml`) or command-line arguments.
*   **F-3.2:** The path to the `oauth_creds.json` file should be configurable, defaulting to `~/.qwen/oauth_creds.json`.

#### 5.4. **Logging & Error Handling**
*   **F-4.1:** The server must provide structured logs for key events: server start/stop, successful API request proxying, successful token refresh.
*   **F-4.2:** The server must log detailed errors for failed API requests and, critically, for failed token refreshes.
*   **F-4.3: Unrecoverable Auth Error:** If a token refresh fails with an unrecoverable error (e.g., `invalid_grant`, `access_denied`), the server must log a fatal error message instructing the user to re-authenticate with the official CLI, and it should stop serving requests until restarted.

### 6. **Technical Requirements & Specifications**

This section codifies the exact technical details reverse-engineered from the official client. Adherence is mandatory for compatibility.

#### 6.1. **Core OAuth 2.0 Constants**
*   **Token URL:** `https://chat.qwen.ai/api/v1/oauth2/token`
*   **Client ID:** `f0304373b74a44d2b584a3fb70ca9e56`

#### 6.2. **Credential File (`~/.qwen/oauth_creds.json`)**
*   **Format:** JSON
*   **Required Fields for Proxy:** `access_token` (string), `refresh_token` (string), `expiry_date` (number, Unix timestamp in milliseconds).

#### 6.3. **API Endpoint Construction**
*   The API base URL must be determined from the `resource_url` field in the token response.
*   If `resource_url` is missing, the fallback URL is `https://dashscope.aliyuncs.com/compatible-mode/v1`.
*   The final URL must be normalized to:
    1.  Start with `https://`.
    2.  End with a `/v1` path segment.

#### 6.4. **Token Refresh Request Specification**
*   **Method:** `POST`
*   **Endpoint:** `https://chat.qwen.ai/api/v1/oauth2/token`
*   **Headers:** `Content-Type: application/json`
*   **Body (JSON):**
    ```json
    {
      "grant_type": "refresh_token",
      "client_id": "f0304373b74a44d2b584a3fb70ca9e56",
      "refresh_token": "[current_refresh_token_from_file]"
    }
    ```

#### 6.5. **Token Expiration Calculation**
*   The `expiry_date` stored in the credentials file is calculated from the token response as: `Date.now() + (expires_in * 1000)`, where `expires_in` is the lifetime of the new token in seconds.

#### 6.6. **Technology Stack**
*   The server should be built with a lightweight, modern framework suitable for I/O-bound tasks (e.g., FastAPI/Flask in Python, Express/Fastify in Node.js).
*   No external database is required. State is managed entirely through the local credentials file.

### 7. **Assumptions and Dependencies**
*   The user has successfully authenticated at least once using the official `qwen-code` CLI to generate the initial `oauth_creds.json`.
*   Qwen's API endpoints, `client_id`, and authentication flow do not significantly change.
*   The user's environment has the necessary runtime (e.g., Python, Node.js) to run the proxy server.

### 8. **Risks and Mitigation**
*   **Risk:** Qwen changes their API or auth flow, breaking the proxy.
    *   **Mitigation:** The project's documentation will clearly state its dependency on the current Qwen-Code implementation. The codebase will be structured to easily update constants like URLs and the `client_id`.
*   **Risk:** The `refresh_token` is revoked or expires, causing a permanent auth failure.
    *   **Mitigation:** Implement clear and actionable logging (F-4.3) to guide the user on how to resolve the issue by re-running the official CLI's auth command.
*   **Risk:** Concurrent writes to the `oauth_creds.json` file could lead to corruption.
    *   **Mitigation:** Implement a file-locking mechanism or an atomic write operation to ensure data integrity when updating the credentials file.

---

## **Product Roadmap: Qwen-Claude Bridge**

### **Phase 1: Minimum Viable Product (MVP) - The Core Engine**
*(Goal: Achieve core functionality and solve the immediate problem.)*

*   **Epic: Core Proxy Server**
    *   Implement HTTP server to listen for requests.
    *   Implement basic request/response translation for `/v1/chat/completions`.
    *   Hardcode necessary configuration (e.g., file path, host/port).
*   **Epic: Stateful Authentication**
    *   Implement logic to read and parse `~/.qwen/oauth_creds.json` on startup.
    *   Implement the reactive token expiration check before each request.
    *   Build and execute the token refresh POST request.
    *   Implement the logic to write new tokens back to the file using a safe/atomic write.
*   **Epic: Basic Usability**
    *   Basic console logging for server status and critical errors.
    *   A `README.md` file explaining how to install, generate the initial token, and run the server.

### **Phase 2: Usability & Robustness**
*(Goal: Make the server easier to configure, more reliable, and developer-friendly.)*

*   **Epic: Advanced Configuration**
    *   Introduce support for a configuration file (e.g., `config.yaml`) to manage host, port, and credential file path.
    *   Add support for environment variables for all configuration options.
*   **Epic: Enhanced Logging & Error Handling**
    *   Implement structured logging (JSON format) for easier parsing.
    *   Introduce log levels (INFO, WARN, ERROR) to control verbosity.
    *   Provide more descriptive error messages to the client and in the logs.
*   **Epic: Improved Packaging**
    *   Package the application for easy installation via a package manager (e.g., PyPI for Python, NPM for Node.js).
    *   Include a simple CLI wrapper (e.g., `qwen-bridge start`).

### **Phase 3: Advanced Features & Polish**
*(Goal: Harden the server for more advanced use cases and deployments.)*

*   **Epic: Deployment & Operations**
    *   Create a `Dockerfile` to allow for easy containerization and deployment.
    *   Add a simple health check endpoint (e.g., `/health`) that returns a `200 OK` status.
*   **Epic: Performance & Security**
    *   Investigate and implement a robust file-locking mechanism for credential writes.
    *   (Optional) Add a simple in-memory cache for Qwen API responses to reduce costs and latency for repeated prompts, if applicable.
*   **Epic: Extensibility**
    *   (Future) Explore adding a helper utility to automate the initial device flow by guiding the user through the process, reducing reliance on the full `qwen-code` CLI installation.
    *   (Future) Document how to extend the proxy to support other Qwen API endpoints if they are added in the future.
